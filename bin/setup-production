#!/usr/bin/env ruby

require 'pathname'
require 'fileutils'
require 'dotenv'

include FileUtils

# if this returns with error
# we can handle that appropriately

# abort if cmd fails
def `(cmd)
  output = super
  abort "'#{cmd}' failed with output: #{output}" unless $?.success?
  output
end

# path to your application root
APP_ROOT = Pathname.new File.expand_path('../../', __FILE__)

chdir APP_ROOT do
  # get env vars for DATABASE and DATAROOT
  Dotenv.load(".env.local", ".env.production", ".env")

  # Load the dashboard specific configuration.
  require APP_ROOT.join("config", "configuration").to_s

  `mkdir -p #{Configuration.dataroot}`

  # currently SQLite-specific
  if File.exist?(Configuration.prod_database)
    # Get a list of all migration for this app
    app_migrations = Dir.glob("#{APP_ROOT}/db/migrate/*").map {|v| File.basename(v).split("_").first}

    # Read in current migrations from database
    require 'sqlite3'
    begin
      db = SQLite3::Database.new Configuration.prod_database
      db_migrations = db.execute("SELECT * FROM schema_migrations").map {|v| v.first}
    rescue SQLite3::Exception => e
      abort "Exception occurred: #{e}"
    ensure
      db.close if db
    end

    # Compare the two arrays of migrations
    unless app_migrations.sort == db_migrations.sort
      abort "Your database differs significantly from the app's schema"
    end
  else
    `RAILS_ENV=production bin/rake db:setup`
  end
end
